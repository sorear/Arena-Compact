=head1 Implementation notes for Arena::Compact

Arena::Compact uses variants of the "BIg Bag Of Pages" algorithm (from
L<http://www.iecc.com/gclist/GC-algorithms.html#Jargon>) to efficiently store
Perl data.  Each page of memory allocated is marked with a template of an
object; for instance all objects with double-precision fields x and y blessed
into Point will share one template, and that template owns pages which are used
only to store points.

The upshot of this is that almost no metadata needs to be kept, in byte terms.
If you have 100 million points in memory, 255 of them will fit on each page,
and you will only use 1.6 GB of memory; each page has 4 bytes to store its
owning format (on a 32-bit system), 255*16 = 4080 bytes of data, and 12 bytes
of slack.

By contrast if the Points were each stored as a blessed HASH reference, this
would require, for each Point, three Perl values; two numbers, each occupying
24 bytes (16 bytes for the SV header, 8 for the actual number), and a hash,
with a 32 byte hash table, a 16 byte header, 24 bytes of hash chain entries,
and 20 bytes of metadata, for a grand total of 140 bytes per Point and 14 GB
for the entire set.  Actually, since that's bigger than 2GB, you need to use a
64-bit perl, which has 8 byte pointers, so more like 20 GB.

=head1 Keys: Space and time efficient comparison of name,type pairs

B<incomplete; since there is only one type only name is used>

Rather than requiring continuous parsing and comparison of names and types, we
use key objects, which are stored in a global intern table key_cache.  Two keys
with the same name and type will always have the same refaddr.  Key objects
cache a parsed representation of the type, for code simplicity.

=head1 Types

In order to pack data effectively, Arena::Compact needs to understand it.
Types tell it how to store and interpret data; they define functions to copy
between a block of memory (with some size and some alignment requirement) and
a SV.  There will eventually be a lot of types; right now there is only scalar
(a SV* represented natively, holding one reference).

=head1 Memory

B<Not yet implemented; a much more restricted system exists directly in formats>

We need to be able to allocate given-size chunks of memory, and identify their
types.  We also need to be able to support large objects somewhat efficiently.
Our current approach us to consider the memory allocated to each subarena as
one contiguous block, such that when we reach the end of a page we use the
page's next pointer to continue; for objects much larger than pages, we may
have internal skip pointers in the objects, or something.

=head1 Formats

Because we condensed names and types into address-sized integers, the
implementation of access to formatted objects is fairly simple; a binary
search is used to locate the correct field for the access, then the type
layer is used to do the actual access.

=head1 Handles

B<incomplete; currently all objects are treated as __persistent_handle>

These are an interesting case, since there are just so many of them.
Conversely, because users are expected to rebless them, cleaning them
up is tricky; relying on DESTROY would make dangling references if the
user screws up, and there's no obvious way to prevent a crash from
ensuing, so we have to use magic.  Conveniently, the magic structure
has enough free space to hold the pointer and the hash chain.

=head1 Future

=over

=item Keys as real cached objects

=item Types other than scalar

=item Pragmatic fields

=item Ephemeral handles

=item Derived/parameterized types

=item Lists

=item User-defined types

=item MooseX

=item Garbage collector (to save on RC bits)

=item Reified formats for one-stop new

=item Immutability

=item XS API?

=item Blessing and reblessing

=item Sub-byte fields

=item Statistics

=item Compaction

=item mummap

=item Storage?

=item Hashes?

=back
